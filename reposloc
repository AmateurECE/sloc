#!/usr/bin/perl

use strict;
use warnings;

use Cwd qw/getcwd/;
use DateTime;
use DateTime::Duration;
use File::Path qw/rmtree/;
use File::Spec::Functions qw/catfile/;
use File::Temp qw/tmpnam/;
use IO::Handle;
use JSON qw/from_json/;
use Switch;

sub print_help;
sub vcs_clone;
sub vcs_revlist;
sub vcs_checkout;

# Parse arguments.
my %opts;
my $na = shift || '.';
while ($na =~ /^-/) {
	switch ($na) {
		case '-sparse' { $opts{sparse} = 1 }
		case '-noplot' { $opts{noplot} = 1 }
		case '-bylang' { $opts{bylang} = 1 }
		case '-nocomments' { $opts{nocomments} = 1 }
		case '-progress' { $opts{progress} = 1 }
		case '-verbose' { $opts{verbose} = 1 }
		else {
			print_help;
			exit
		}
	}
	$na = shift || '.';
}
my $repo = "";
my $vcs = "";
if ($na =~ /^git::(.*)$/) {
	$vcs = "git";
	$repo = $1;
} elsif ($na =~ /^hg::(.*)$/) {
	$vcs = "hg";
	$repo = $1;
} else {
	$repo = $na;
	# autodetect based on presence of '.git', '.hg' etc.
	if (-d catfile($repo, ".git")) {
		$vcs = "git";
	} elsif (-d catfile($repo, ".hg")) {
		$vcs = "hg";
	} else {
		die "directory does not appear to be a repository";
	}
}

print STDERR "Cloning repository...\n" if $opts{progress};
my $calldir = getcwd;
my $destrepo = tmpnam();
vcs_clone $vcs, $repo, $destrepo;
chdir $destrepo or die $!;

# Read list of commits
print STDERR "Reading commits...\n" if $opts{progress};
my @commit_info = vcs_revlist $vcs;

# Pick commits to be processed
my @commits;
if ($opts{sparse}) {
	my $last = DateTime->from_epoch(epoch => 0);
	for (@commit_info) {
		my ($ts, $rev) = split / /;
		my $dt = DateTime->from_epoch(epoch => $ts);
		$dt->truncate(to=>"day");
		if ($dt->delta_days($last)->in_units('days') >= 1) {
			$last = $dt;
			push @commits, "$ts $rev";
		}
	}
} else {
	@commits = @commit_info;
}

# Collect all data from sloc
my $i = 0;
my $ccount = $#commits + 1;
my %data;
my %langsh;
for (@commits) {
	$i++;
	print STDERR "Fetching statistics: $i / $ccount\n" if $opts{progress};
	my ($ts, $rev) = split / /;
	vcs_checkout $vcs, $rev;
	my $json = `sloc -json`;
	my $result = from_json $json or die $!;
	$data{$ts} = $result;
	$langsh{$_} = 1 for keys $result; 
}
my @langs = keys %langsh;

# Post-process and graph

my $out;
my $dfilename = tmpnam();
unless ($opts{noplot}) {
	# gnuplot is rather limited, so we'll need to write the data to a
	# temporary file.
	open $out, ">", $dfilename or die $!;
} else {
	$out = \*STDOUT;
}

# Header
print $out "Date ";
if ($opts{bylang}) {
	for my $lang (@langs) {
		print $out "$lang ";
	}
} else {
	unless ($opts{nocomments}) {
		print $out "Code Comments";
	} else {
		print $out "Code";
	}
}
print $out "\n";

for (@commits) {
	my ($ts, $rev) = split / /;
	my $result = $data{$ts};
	print $out "$ts ";
	if ($opts{bylang}) {
		my $v = 0;
		for my $lang (@langs) {
			my $r = $result->{$lang};
			$v += $r->{CodeLines} if $r;
			$v += $r->{CommentLines} if $r and not $opts{nocomments};
			print $out "$v ";
		}
	} else {
		my ($code, $comment) = (0, 0);
		for my $lang (keys $result) {
			$code += $result->{$lang}{CodeLines};
			$comment += $result->{$lang}{CommentLines};
		}
		print $out $code;
		my $total = $code + $comment;
		print $out " $total" unless $opts{nocomments};
	}
	print $out "\n";
}

unless ($opts{noplot}) {
	close $out or die $!;
	my $gp;
	open $gp, "| gnuplot" or die $!;
	$gp->autoflush(1);
	my $outfile = catfile($calldir, 'output.png');
	print $gp <<END;
set terminal png size 800, 580
set output '$outfile'
set xdata time
set timefmt "%s"
END
	unless ($opts{bylang}) {
		if ($opts{nocomments}) {
			print $gp "plot '$dfilename' using 1:2 with filledcurves y1=0 title columnheader\n";
		} else {
			print $gp "plot '$dfilename' using 1:3 with filledcurves y1=0 title columnheader, '' using 1:2 with filledcurves y1=0 title columnheader\n";
		}
	} else {
		# One part for each language
		print $gp "plot '$dfilename' ";
		for (my $i = $#langs+2; $i > 2; $i--) {
			print $gp "using 1:$i with filledcurves y1=0 title columnheader, '' ";
		}
		print $gp "using 1:2 with filledcurves y1=0 title columnheader\n";
	}
	print $gp "exit\n";
	wait;
	close $gp or die $!;
	rm $dfilename or die $!;
}

chdir $calldir;
rmtree $destrepo;

sub print_help {
	print<<END;
usage: $0 [OPTIONS] [[VCS::]REPOSITORY] ...
options:
  -sparse      Iterate on dates rather than commits
  -noplot      Don't pass to gnuplot; just print to standard output
  -bylang      Show statistics for individual languages
  -nocomments  Don't include comment counts
  -progress    Display progress information
  -verbose     Print extra information
END
}

sub vcs_clone {
	my ($vcs, $repo, $destrepo) = @_;
	switch ($vcs) {
		case "git" {
			my @cmd = ("git", "clone", "-b", "master");
			push @cmd, "-q" unless $opts{verbose};
			push @cmd, $repo, $destrepo;
			print ("> " . (join ' ', @cmd) . "\n");
			die "git clone failed" if system @cmd;
		}
		case "hg" {
			my @cmd = ("hg", "clone", "-b", "default");
			push @cmd, "-q" unless $opts{verbose};
			push @cmd, $repo, $destrepo;
			print ("> " . (join ' ', @cmd) . "\n");
			die "mercurial clone failed" if system @cmd;
		}
	}
}

sub git_revlist {
	my @rl;
	open IN, 'git rev-list master --reverse --timestamp |' or die $!;
	while (<IN>) {
		chomp;
		push @rl, $_;
	}
	close IN or die $!;
	return @rl;
}

sub hg_revlist {
	my @rl;
	open IN, 'hg log -f --template "{date} {node}\n" |' or die $!;
	while (<IN>) {
		chomp;
		my ($d, $rev) = split / /;
		my ($ts, $ms) = split /\./, $d;
		push @rl, "$ts $rev";
	}
	close IN or die $!;
	return (reverse @rl);
}

sub vcs_revlist {
	my ($vcs) = @_;
	switch ($vcs) {
		case "git" { return git_revlist; }
		case "hg" { return hg_revlist; }
	}
}

sub vcs_checkout {
	my ($vcs, $rev) = @_;
	switch ($vcs) {
		case "git" { system "git checkout --quiet $rev"; }
		case "hg" { system "hg checkout --quiet $rev"; }
	}
}

__END__

=head1 NAME

reposloc - get source-lines-of-code statistics from a git or mercurial
repository

=head1 SYNOPSIS

B<reposloc> [I<OPTIONS>] [[I<VCS>::]I<REPOSITORY>] ...

=head1 DESCRIPTION

B<reposloc> performs source-lines-of-code analysis on a repository's history
and produces graphs of the number of lines of code versus time. Supported
version control systems are I<git>(1) and I<hg>(1) - if none is specified,
B<reposloc> will attempt to autodetect the system used. Autodetection does not
work on "bare" repositories. If multiple repositories are specified, they will
be treated as a single large repository.

B<reposloc> has two main modes of operation: it can tally total statistics
across languages, or it can tally statistics for each language individually,
with the intent of comparison.

=head1 OPTIONS

=over

=item B<-sparse>

By default, B<reposloc> will look at every single commit in the repository. For
large repositories (with more than a few thousand commits) or multiple
repositories, this takes quite a while and is mostly a waste of time. Using
B<-sparse> tells reposloc only to collect one data point per day.

=item B<-noplot>

Dump the resulting data to standard output without handing it off to I<gnuplot>(1).

=item B<-bylang>

Collects data on a per-language basis for comparison between languages, rather
than only collecting total statistics (more useful for broad graphs and
comparing SLoC with comments).

=item B<-nocomments>

In "totals" mode, just graph the number of lines of code, and don't display
data for amount of comments. In by-language mode (with B<-bylang>), doesn't
include comments in each language's statistic.

=item B<-progress>

Print progress information to standard error.

=item B<-verbose>

Shows what commands are being run, and instructs those commands to print their
own verbose information. This option may not go well with B<-progress>.

=back

=head1 BUGS

Analysis of branches other than C<master> is not supported.

Please report any further bugs found to the author.

=head1 AUTHOR

Scott Lawrence <bytbox@gmail.com>

=head1 SEE ALSO

I<sloc>(1)

