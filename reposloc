#!/usr/bin/perl

# TODO use proper temporary files

use strict;
use warnings;

use Cwd qw/getcwd/;
use DateTime;
use DateTime::Duration;
use File::Path qw/rmtree/;
use File::Spec::Functions qw/catfile/;
use IO::Handle;
use JSON qw/from_json/;
use Switch;

sub print_help;

# Parse arguments.
my %opts;
my $na = shift || '.';
while ($na =~ /^-/) {
	switch ($na) {
		case '-sparse' { $opts{sparse} = 1 }
		case '-noplot' { $opts{noplot} = 1 }
		case '-bylang' { $opts{bylang} = 1 }
		case '-nocomments' { $opts{nocomments} = 1 }
		case '-progress' { $opts{progress} = 1 }
		else {
			print_help;
			exit
		}
	}
	$na = shift || '.';
}
my $repo = $na;

print STDERR "Cloning repository...\n" if $opts{progress};
my $calldir = getcwd;
my $destrepo = '/tmp/reposloc-' . int(rand(10000000));
die "VCS call failed" if system "git", "clone", "-q", "-b", "master", $repo, $destrepo;
chdir $destrepo or die $!;

# Read list of commits
print STDERR "Reading commits...\n" if $opts{progress};
my @commit_info;
open IN, 'git rev-list master --reverse --timestamp |' or die $!;
while (<IN>) {
	chomp;
	push @commit_info, $_;
}
close IN or die $!;

# Pick commits to be processed
my @commits;
if ($opts{sparse}) {
	my $last = DateTime->from_epoch(epoch => 0);
	for (@commit_info) {
		my ($ts, $rev) = split / /;
		my $dt = DateTime->from_epoch(epoch => $ts);
		$dt->truncate(to=>"day");
		if ($dt->delta_days($last)->in_units('days') >= 1) {
			$last = $dt;
			push @commits, "$ts $rev";
		}
	}
} else {
	@commits = @commit_info;
}

# Collect all data from sloc
my $i = 0;
my $ccount = $#commits + 1;
my %data;
my %langsh;
for (@commits) {
	$i++;
	print STDERR "Fetching statistics: $i / $ccount\n" if $opts{progress};
	my ($ts, $rev) = split / /;
	system "git checkout --quiet $rev";
	my $json = `sloc -json`;
	my $result = from_json $json or die $!;
	$data{$ts} = $result;
	$langsh{$_} = 1 for keys $result; 
}
my @langs = keys %langsh;

# Post-process and graph

my $out;
my $dfilename = '/tmp/reposloc-data-' . int(rand(10000000));
unless ($opts{noplot}) {
	# gnuplot is rather limited, so we'll need to write the data to a
	# temporary file.
	open $out, ">", $dfilename or die $!;
} else {
	$out = \*STDOUT;
}

# Header
print $out "Date ";
if ($opts{bylang}) {
	for my $lang (@langs) {
		print $out "$lang ";
	}
} else {
	unless ($opts{nocomments}) {
		print $out "Code Comments";
	} else {
		print $out "Code";
	}
}
print $out "\n";

for (@commits) {
	my ($ts, $rev) = split / /;
	my $result = $data{$ts};
	print $out "$ts ";
	if ($opts{bylang}) {
		my $v = 0;
		for my $lang (@langs) {
			my $r = $result->{$lang};
			$v += $r->{CodeLines} if $r;
			$v += $r->{CommentLines} if $r and not $opts{nocomments};
			print $out "$v ";
		}
	} else {
		my ($code, $comment) = (0, 0);
		for my $lang (keys $result) {
			$code += $result->{$lang}{CodeLines};
			$comment += $result->{$lang}{CommentLines};
		}
		print $out $code;
		my $total = $code + $comment;
		print $out " $total" unless $opts{nocomments};
	}
	print $out "\n";
}

unless ($opts{noplot}) {
	close $out or die $!;
	my $gp;
	open $gp, "| gnuplot" or die $!;
	$gp->autoflush(1);
	my $outfile = catfile($calldir, 'output.png');
	print $gp <<END;
set terminal png size 800, 580
set output '$outfile'
set xdata time
set timefmt "%s"
END
	unless ($opts{bylang}) {
		if ($opts{nocomments}) {
			print $gp "plot '$dfilename' using 1:2 with lines title columnheader\n";
		} else {
			print $gp "plot '$dfilename' using 1:2 with lines title columnheader, '' using 1:3 with lines title columnheader\n";
		}
	} else {
		# One part for each language
		print $gp "plot '$dfilename' using 1:2 with lines title columnheader";
		for (my $i = 3; $i < ($#langs+3); $i++) {
			print $gp ", '' using 1:$i with lines title columnheader";
		}
		print $gp "\n";
	}
	print $gp "exit\n";
	wait;
	close $gp or die $!;
	rm $dfilename or die $!;
}

chdir $calldir;
rmtree $destrepo;

sub print_help {
	print<<END;
usage: $0 [OPTIONS] [[VCS::]REPOSITORY] ...
options:
  -sparse      Iterate on dates rather than commits
  -noplot      Don't pass to gnuplot; just print to standard output
  -bylang      Show statistics for individual languages
  -nocomments  Don't include comment counts
  -progress    Display progress information
END
}

__END__

=head1 NAME

reposloc - get source-lines-of-code statistics from a git or mercurial
repository

=head1 SYNOPSIS

B<reposloc> [I<OPTIONS>] [[I<VCS>::]I<REPOSITORY>] ...

=head1 DESCRIPTION

B<reposloc> performs source-lines-of-code analysis on a repository's history
and produces graphs of the number of lines of code versus time. Supported
version control systems are I<git>(1) and I<hg>(1) - if none is specified,
B<reposloc> will attempt to autodetect the system used. Autodetection does not
work on "bare" repositories. If multiple repositories are specified, they will
be treated as a single large repository.

B<reposloc> has two main modes of operation: it can tally total statistics
across languages, or it can tally statistics for each language individually,
with the intent of comparison.

=head1 OPTIONS

=over

=item B<-sparse>

By default, B<reposloc> will look at every single commit in the repository. For
large repositories (with more than a few thousand commits) or multiple
repositories, this takes quite a while and is mostly a waste of time. Using
B<-sparse> tells reposloc only to collect one data point per day.

=item B<-noplot>

Dump the resulting data to standard output without handing it off to I<gnuplot>(1).

=item B<-bylang>

Collects data on a per-language basis for comparison between languages, rather
than only collecting total statistics (more useful for broad graphs and
comparing SLoC with comments).

=item B<-nocomments>

In "totals" mode, just graph the number of lines of code, and don't display
data for amount of comments. In by-language mode (with B<-bylang>), doesn't
include comments in each language's statistic.

=item B<-progress>

Print progress information to standard error.

=back

=head1 BUGS

Analysis of branches other than C<master> is not supported.

Please report any further bugs found to the author.

=head1 AUTHOR

Scott Lawrence <bytbox@gmail.com>

=head1 SEE ALSO

I<sloc>(1)

